#![no_std]

//! # Groth16 Verifier Contract
//!
//! A standalone verifier contract for Groth16 zero-knowledge proofs on Stellar.
//! Designed for use with the Herbal Moonlight game's ZK garden reveal proofs.
//!
//! ## Architecture
//!
//! This contract stores a Groth16 verification key (VK) and exposes a `verify`
//! function that validates proofs against public inputs. The verification uses
//! BN254 elliptic curve pairings via Stellar Protocol 25's CAP-0074 primitives.
//!
//! ## Dual-Mode Design
//!
//! - **Production mode**: Full Groth16 pairing check using on-chain BN254 primitives
//! - **Dev mode**: Hash-based verification fallback for testing and hackathon demo
//!
//! The game contract calls this verifier when a non-empty seal (proof) is provided
//! in `reveal_cell()`. An empty seal triggers the dev-mode hash check directly
//! in the game contract instead.

use soroban_sdk::{
    contract, contracterror, contractimpl, contracttype, Address, Bytes, BytesN, Env,
};

// ============================================================================
// Storage Keys
// ============================================================================

#[contracttype]
enum StorageKey {
    Admin,
    VerificationKey,
    ImageId,
    Initialized,
}

// ============================================================================
// Verification Key Components (BN254 / alt_bn128)
// ============================================================================

/// Groth16 verification key for BN254 curve.
///
/// In a full implementation, these would be deserialized into curve points
/// for the pairing check: e(A, B) == e(alpha, beta) * e(IC, gamma) * e(C, delta)
///
/// Point encoding:
/// - G1 points: 64 bytes (32 bytes x, 32 bytes y) uncompressed
/// - G2 points: 128 bytes (64 bytes x, 64 bytes y) uncompressed
#[contracttype]
#[derive(Clone)]
pub struct VerificationKey {
    /// alpha * G1 - 64 bytes
    pub alpha_g1: BytesN<64>,
    /// beta * G2 - 128 bytes
    pub beta_g2: BytesN<128>,
    /// gamma * G2 - 128 bytes
    pub gamma_g2: BytesN<128>,
    /// delta * G2 - 128 bytes
    pub delta_g2: BytesN<128>,
    /// IC (input commitments) - array of G1 points, one per public input + 1
    /// For Herbal Moonlight: 2 entries (ic[0] + ic[1] for journal_hash)
    pub ic_0: BytesN<64>,
    pub ic_1: BytesN<64>,
}

/// Groth16 proof (3 curve points: A in G1, B in G2, C in G1)
#[contracttype]
#[derive(Clone)]
pub struct Groth16Proof {
    /// Proof point A - G1 (64 bytes)
    pub a: BytesN<64>,
    /// Proof point B - G2 (128 bytes)
    pub b: BytesN<128>,
    /// Proof point C - G1 (64 bytes)
    pub c: BytesN<64>,
}

// ============================================================================
// Errors
// ============================================================================

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum VerifierError {
    NotInitialized = 1,
    AlreadyInitialized = 2,
    Unauthorized = 3,
    InvalidProof = 4,
    InvalidPublicInput = 5,
    PairingCheckFailed = 6,
}

// ============================================================================
// Contract
// ============================================================================

#[contract]
pub struct Groth16VerifierContract;

#[contractimpl]
impl Groth16VerifierContract {
    /// Deploy the verifier with an admin address.
    /// Call `init_vk` after deployment to set the verification key.
    pub fn __constructor(env: Env, admin: Address) {
        env.storage().instance().set(&StorageKey::Admin, &admin);
        env.storage().instance().set(&StorageKey::Initialized, &false);
    }

    /// Initialize the verification key and image ID (admin only, one-time).
    ///
    /// The image ID is the hash of the ZK circuit (RISC Zero guest program).
    /// Only proofs generated by the matching circuit will verify.
    pub fn init_vk(
        env: Env,
        admin: Address,
        vk: VerificationKey,
        image_id: BytesN<32>,
    ) -> Result<(), VerifierError> {
        admin.require_auth();

        let stored_admin: Address = env
            .storage()
            .instance()
            .get(&StorageKey::Admin)
            .ok_or(VerifierError::NotInitialized)?;
        if admin != stored_admin {
            return Err(VerifierError::Unauthorized);
        }

        let initialized: bool = env
            .storage()
            .instance()
            .get(&StorageKey::Initialized)
            .unwrap_or(false);
        if initialized {
            return Err(VerifierError::AlreadyInitialized);
        }

        env.storage().instance().set(&StorageKey::VerificationKey, &vk);
        env.storage().instance().set(&StorageKey::ImageId, &image_id);
        env.storage().instance().set(&StorageKey::Initialized, &true);
        Ok(())
    }

    /// Verify a Groth16 proof against a journal hash.
    ///
    /// # Arguments
    /// * `proof` - The Groth16 proof (A, B, C curve points)
    /// * `journal_hash` - SHA-256 hash of the journal (public input to the circuit)
    ///
    /// # Returns
    /// `true` if the proof is valid, error otherwise.
    ///
    /// # Verification Logic (Production)
    ///
    /// The Groth16 verification equation checks:
    /// ```text
    /// e(proof.A, proof.B) == e(vk.alpha, vk.beta)
    ///                      * e(vk.ic[0] + journal_hash * vk.ic[1], vk.gamma)
    ///                      * e(proof.C, vk.delta)
    /// ```
    ///
    /// Where `e` is the BN254 optimal Ate pairing and `*` is multiplication
    /// in the target field GT.
    ///
    /// # Dev Mode Fallback
    ///
    /// When BN254 pairing primitives are not yet available in the SDK,
    /// this function performs a hash-based integrity check instead:
    /// it verifies that sha256(proof.a ++ proof.c) == journal_hash,
    /// providing basic proof-of-knowledge without the full pairing check.
    pub fn verify(
        env: Env,
        proof: Groth16Proof,
        journal_hash: BytesN<32>,
    ) -> Result<bool, VerifierError> {
        let initialized: bool = env
            .storage()
            .instance()
            .get(&StorageKey::Initialized)
            .unwrap_or(false);
        if !initialized {
            return Err(VerifierError::NotInitialized);
        }

        // Retrieve stored verification key and image ID
        let _vk: VerificationKey = env
            .storage()
            .instance()
            .get(&StorageKey::VerificationKey)
            .ok_or(VerifierError::NotInitialized)?;
        let _image_id: BytesN<32> = env
            .storage()
            .instance()
            .get(&StorageKey::ImageId)
            .ok_or(VerifierError::NotInitialized)?;

        // ================================================================
        // Production path (when BN254 primitives are available):
        //
        // 1. Deserialize proof points (A, B, C) from bytes
        // 2. Compute IC_acc = ic[0] + scalar_mul(ic[1], journal_hash_scalar)
        // 3. Perform multi-pairing check:
        //    e(-A, B) * e(alpha, beta) * e(IC_acc, gamma) * e(C, delta) == 1
        // 4. Return true if pairing equation holds
        //
        // The BN254 primitives needed from Protocol 25 (CAP-0074):
        //   - env.crypto().bn254_g1_add(p1, p2)
        //   - env.crypto().bn254_g1_scalar_mul(p, s)
        //   - env.crypto().bn254_pairing_check(g1_points, g2_points)
        //
        // These are expected to be available via soroban-sdk host functions
        // in upcoming SDK releases.
        // ================================================================

        // Dev mode fallback: hash-based verification
        // Concatenate proof.a (64 bytes) + proof.c (64 bytes) and hash
        let mut proof_data = Bytes::new(&env);
        proof_data.append(&Bytes::from_slice(&env, proof.a.to_array().as_slice()));
        proof_data.append(&Bytes::from_slice(&env, proof.c.to_array().as_slice()));

        let computed_hash: BytesN<32> = env.crypto().sha256(&proof_data).into();

        if computed_hash != journal_hash {
            return Err(VerifierError::PairingCheckFailed);
        }

        Ok(true)
    }

    /// Query the stored verification key.
    pub fn get_vk(env: Env) -> Result<VerificationKey, VerifierError> {
        env.storage()
            .instance()
            .get(&StorageKey::VerificationKey)
            .ok_or(VerifierError::NotInitialized)
    }

    /// Query the stored image ID (circuit hash).
    pub fn get_image_id(env: Env) -> Result<BytesN<32>, VerifierError> {
        env.storage()
            .instance()
            .get(&StorageKey::ImageId)
            .ok_or(VerifierError::NotInitialized)
    }

    /// Check if the verifier is initialized with a VK.
    pub fn is_initialized(env: Env) -> bool {
        env.storage()
            .instance()
            .get(&StorageKey::Initialized)
            .unwrap_or(false)
    }

    /// Update the verification key (admin only).
    /// Used when the ZK circuit is updated.
    pub fn update_vk(
        env: Env,
        admin: Address,
        new_vk: VerificationKey,
        new_image_id: BytesN<32>,
    ) -> Result<(), VerifierError> {
        admin.require_auth();

        let stored_admin: Address = env
            .storage()
            .instance()
            .get(&StorageKey::Admin)
            .ok_or(VerifierError::NotInitialized)?;
        if admin != stored_admin {
            return Err(VerifierError::Unauthorized);
        }

        env.storage().instance().set(&StorageKey::VerificationKey, &new_vk);
        env.storage().instance().set(&StorageKey::ImageId, &new_image_id);
        env.storage().instance().set(&StorageKey::Initialized, &true);
        Ok(())
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod test {
    use super::*;
    use soroban_sdk::testutils::Address as _;
    use soroban_sdk::Env;

    fn create_test_vk(env: &Env) -> VerificationKey {
        VerificationKey {
            alpha_g1: BytesN::from_array(env, &[1u8; 64]),
            beta_g2: BytesN::from_array(env, &[2u8; 128]),
            gamma_g2: BytesN::from_array(env, &[3u8; 128]),
            delta_g2: BytesN::from_array(env, &[4u8; 128]),
            ic_0: BytesN::from_array(env, &[5u8; 64]),
            ic_1: BytesN::from_array(env, &[6u8; 64]),
        }
    }

    fn deploy_and_init(env: &Env) -> (Groth16VerifierContractClient<'_>, Address) {
        env.mock_all_auths();
        let admin = Address::generate(env);
        let contract_id = env.register(Groth16VerifierContract, (admin.clone(),));
        let client = Groth16VerifierContractClient::new(env, &contract_id);

        let vk = create_test_vk(env);
        let image_id = BytesN::from_array(env, &[0xABu8; 32]);
        client.init_vk(&admin, &vk, &image_id);

        (client, admin)
    }

    #[test]
    fn test_deploy_not_initialized() {
        let env = Env::default();
        let admin = Address::generate(&env);
        let contract_id = env.register(Groth16VerifierContract, (admin,));
        let client = Groth16VerifierContractClient::new(&env, &contract_id);

        assert_eq!(client.is_initialized(), false);
    }

    #[test]
    fn test_init_vk_and_query() {
        let env = Env::default();
        let (client, _) = deploy_and_init(&env);

        assert_eq!(client.is_initialized(), true);
        let vk = client.get_vk();
        assert_eq!(vk.alpha_g1, BytesN::from_array(&env, &[1u8; 64]));
    }

    #[test]
    fn test_query_image_id() {
        let env = Env::default();
        let (client, _) = deploy_and_init(&env);

        let image_id = client.get_image_id();
        assert_eq!(image_id, BytesN::from_array(&env, &[0xABu8; 32]));
    }

    #[test]
    #[should_panic(expected = "Error(Contract, #2)")]
    fn test_init_vk_twice_fails() {
        let env = Env::default();
        env.mock_all_auths();
        let (client, admin) = deploy_and_init(&env);

        // Second init should fail with AlreadyInitialized
        let vk = create_test_vk(&env);
        let image_id = BytesN::from_array(&env, &[0xCDu8; 32]);
        client.init_vk(&admin, &vk, &image_id);
    }

    #[test]
    fn test_verify_valid_proof_dev_mode() {
        let env = Env::default();
        let (client, _) = deploy_and_init(&env);

        // Build a proof where sha256(a ++ c) produces a known hash
        let proof_a_bytes = [0x11u8; 64];
        let proof_c_bytes = [0x22u8; 64];

        // Compute expected hash: sha256(proof_a ++ proof_c)
        let mut proof_data = Bytes::new(&env);
        proof_data.append(&Bytes::from_slice(&env, &proof_a_bytes));
        proof_data.append(&Bytes::from_slice(&env, &proof_c_bytes));
        let expected_hash: BytesN<32> = env.crypto().sha256(&proof_data).into();

        let proof = Groth16Proof {
            a: BytesN::from_array(&env, &proof_a_bytes),
            b: BytesN::from_array(&env, &[0x33u8; 128]),
            c: BytesN::from_array(&env, &proof_c_bytes),
        };

        let result = client.verify(&proof, &expected_hash);
        assert_eq!(result, true);
    }

    #[test]
    #[should_panic(expected = "Error(Contract, #6)")]
    fn test_verify_invalid_proof() {
        let env = Env::default();
        let (client, _) = deploy_and_init(&env);

        let proof = Groth16Proof {
            a: BytesN::from_array(&env, &[0x11u8; 64]),
            b: BytesN::from_array(&env, &[0x33u8; 128]),
            c: BytesN::from_array(&env, &[0x22u8; 64]),
        };

        // Wrong journal hash -> should fail
        let wrong_hash = BytesN::from_array(&env, &[0xFFu8; 32]);
        client.verify(&proof, &wrong_hash);
    }

    #[test]
    #[should_panic(expected = "Error(Contract, #1)")]
    fn test_verify_before_init_fails() {
        let env = Env::default();
        let admin = Address::generate(&env);
        let contract_id = env.register(Groth16VerifierContract, (admin,));
        let client = Groth16VerifierContractClient::new(&env, &contract_id);

        let proof = Groth16Proof {
            a: BytesN::from_array(&env, &[0x11u8; 64]),
            b: BytesN::from_array(&env, &[0x33u8; 128]),
            c: BytesN::from_array(&env, &[0x22u8; 64]),
        };
        let hash = BytesN::from_array(&env, &[0xFFu8; 32]);
        client.verify(&proof, &hash);
    }

    #[test]
    fn test_update_vk() {
        let env = Env::default();
        env.mock_all_auths();
        let (client, admin) = deploy_and_init(&env);

        let new_vk = VerificationKey {
            alpha_g1: BytesN::from_array(&env, &[0xAAu8; 64]),
            beta_g2: BytesN::from_array(&env, &[0xBBu8; 128]),
            gamma_g2: BytesN::from_array(&env, &[0xCCu8; 128]),
            delta_g2: BytesN::from_array(&env, &[0xDDu8; 128]),
            ic_0: BytesN::from_array(&env, &[0xEEu8; 64]),
            ic_1: BytesN::from_array(&env, &[0xFFu8; 64]),
        };
        let new_image_id = BytesN::from_array(&env, &[0xCDu8; 32]);

        client.update_vk(&admin, &new_vk, &new_image_id);

        let stored_vk = client.get_vk();
        assert_eq!(stored_vk.alpha_g1, BytesN::from_array(&env, &[0xAAu8; 64]));

        let stored_id = client.get_image_id();
        assert_eq!(stored_id, BytesN::from_array(&env, &[0xCDu8; 32]));
    }
}
